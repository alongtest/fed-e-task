## Javascript性能优化

### GC算法

GC就是垃圾回收机制
常见GC算法
- 引用计数
- 标记清除
- 标记整理
- 分代回收

#### 引用计数

内部通过引用计数器维护对象的引用数，对象引用关系改变时修改引用数值，引用数字为0时立即回收

优点 
- 发现垃圾立即回收，当引用数为零时立即回收垃圾对象
- 最大限度减少程序暂停，减少程序卡顿时间
缺点
- 无法回收循环引用的对象
```
function () {
    const obj1 = {}
    const obj2 = {}
    
    obj1.next = obj2;
    obj2.next = obj1;
}
// 引用计数无法回收上述 循环引用的对象
```
- 资源消耗大、时间开销大。需要维护对象的引用数

#### 标记清除

将垃圾回收分成两个阶段，分别是标记和回收  
- 在标记阶段，会遍历所有对象并标记活动对象（从根部可访问到的对象）
- 在回收阶段，遍历所有对象清楚没有标记的对象
- 通过两次的遍历行为回收垃圾内存

优点
- 解决循环引用对象的回收问题（相对于引用计数算法）

缺点
- 空间碎片化，内存地址不连续，空间无法完全利用
- 不能立即回收垃圾对象，会等到标记完成后统一执行清除操作，清楚过程中程序是不能工作的

#### 标记整理

标记整理也将垃圾回收分成两个阶段
标记阶段与标记清楚算法一致，
清除阶段会先执行整理操作，移动活动对象位置为连续地址
接下来整体回收活动对象边界右侧的内存

优点
- 减少空间碎片化问题

缺点
- 不会立即回收垃圾对象

### v8引擎
 速度快，即时编译  
内存设限 64位 不超过1.5g 32位 不超过800m

#### V8垃圾回收策略

v8内存设有上先，采用分代回收的思路，不同代内存执行不同的回收算法

V8  GC 涉及的算法
- 分代回收
- 空间复制
- 标记清楚
- 标记整理
- 标记增量

采用分代回收的思想，内存分为新生代和老生代，小空间用于存储新生代对象（32M|16M)  
新生代存放存活时间较短的对象（如局部作用域变量）

新生代对象回收，新生代中用 Scavenge 算法来处理
通过标记整理和复制算法实现
- 新生代内存会等分为两个空间，使用状态空间称为From，空闲空间称为To空间，From空间用于存储活动对象。
- 当对象区域快被写满时，就需要执行一次垃圾清理操作。对From空间执行标记，之后会把存活对象复制到To空间，并有序排列起来
- 接下来两个空间角色互换，直接释放掉原来的From空间

一轮GC操作之后还存活的对象会晋升到老生代内存中，如果To空间使用率超过25%，新生代的对象也会晋升到老生代内存中

老生代对象回收，64位 1.4G 32 位 700M
老生代会存储 全局变量下的对象，一部分闭包中的数据
老生代中采用 标记清除、标记整理、增量标记算法
- 通过标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化，老生代不足以存储即将存储的对象，会触发标记整理操作
- 采用增量标记进行效率优化，GC操作会阻塞程序的执行，增量标记将整个标记过程拆分开来，每一个片段与程序执行交替进行。最后阻塞程序执行清除操作





